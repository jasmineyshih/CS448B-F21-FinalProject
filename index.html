<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>
<script src="scripts/preprocess.js"></script>

<style>
    .fakeRootElements {
        visibility: hidden;
    }
    .selectedNode {
        stroke: black !important;
        stroke-width: 2px;
        fill-opacity: 1;
    }
    .collapsedNode {
        stroke: #999;
        fill: url(#patternCheckers);
        stroke-width: 2px;
        fill-opacity: 1;
    }
    .checker {
        fill: #777;
    }
    .dimmedEdges {
        stroke-opacity: 0.1;
    }
    .highlightedEdges {
        stroke-opacity: 0.8;
    }
    #collapseExpandButton {
        visibility: hidden;
    }
    .showButton {
        visibility: visible !important;
    }
    .hiddenNodes {
        visibility: hidden !important;
    }
    .hiddenEdges {
        visibility: hidden !important;
    }
    #tooltip {
        position: absolute;			
        text-align: left;			
        width: auto;				
        height: auto;					
        padding: 5px;				
        font: 10px sans-serif;		
        background: lightsteelblue;	
        border: 0px;		
        border-radius: 8px;			
        pointer-events: none;
    }
    .attributeContainer {
        width: 100%;
    }
    .attributeLabel {
        width: 80px;
        display: inline;
    }
    .attributeValue {
        display: inline;
    }
</style>

<div>
    <div>
        <span>Use divergent coloring on</span>
        <input type="checkbox" name="treeEdgeColoring" onclick="updateEdgeColors('tree')" checked>
        <label for="treeEdgeColoring">tree edges</label>
        <input type="checkbox" name="extraEdgeAcrossColoring" onclick="updateEdgeColors('extraWithin')" checked>
        <label for="extraEdgeAcrossColoring">extra edges within level</label>
        <input type="checkbox" name="extraEdgeAcrossColoring" onclick="updateEdgeColors('extraAcross')" checked>
        <label for="extraEdgeAcrossColoring">extra edges across levels</label>
    </div>
    <div>
        <span>Vary node size by</span>
        <input type="radio" id="numLikes" name="nodeSizeAttribute" value="numLikes" onclick="updateNodeSizeAttribute(this)">
        <label for="numLikes">Number of Likes</label>
        <input type="radio" id="numCommentss" name="nodeSizeAttribute" value="numComments" onclick="updateNodeSizeAttribute(this)">
        <label for="numCommentss">Number of Comments</label>
        <input type="radio" id="likesCommentsRatio" name="nodeSizeAttribute" value="numComments/numLikes" onclick="updateNodeSizeAttribute(this)">
        <label for="likesCommentsRatio">Comments / Likes</label>
        <input type="radio" id="uniformNodeSize" name="nodeSizeAttribute" value="" onclick="updateNodeSizeAttribute(this)" checked>
        <label for="uniformNodeSize">Use uniform size</label>
    </div>
    <div>
        <button id="collapseExpandButton" onclick="collapseOrExpandSelectedNode()"></button>
    </div>
</div>
<!-- Create a div where the graph will take place -->
<div id="viz">
    <div id="tooltip">
        <div class="attributeContainer">
            <div class="attributeLabel">Node ID:</div>
            <div class="attributeValue" id="idField">###</div>
        </div>
        <div class="attributeContainer">
            <div class="attributeLabel">Timestamp:</div>
            <div class="attributeValue" id="timestampField">###</div>
        </div>
        <div class="attributeContainer">
            <div class="attributeLabel">Number of Likes:</div>
            <div class="attributeValue" id="numLikesField">###</div>
        </div>
        <div class="attributeContainer">
            <div class="attributeLabel">Number of Comments:</div>
            <div class="attributeValue" id="numCommentsField">###</div>
        </div>
        <div class="attributeContainer">
            <div class="attributeLabel">Degree of Contribution:</div>
            <div class="attributeValue" id="degContributionField">###</div>
        </div>
    </div>
    <svg>
        <defs>
            <linearGradient id="verticalGradFollowedUp" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
                <stop offset="100%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
            </linearGradient>
            <linearGradient id="verticalGradFollowerUp" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
                <stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
            </linearGradient>
            <linearGradient id="horizontalGradFollowedLeft" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
                <stop offset="100%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
            </linearGradient>
            <linearGradient id="horizontalGradFollowerLeft" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
                <stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
            </linearGradient>
            <pattern id="patternCheckers" x="0" y="0" width="4" height="4" patternUnits="userSpaceOnUse" >
                <rect class="checker" x="0" width="2" height="2" y="0"/>
                <rect class="checker" x="2" width="2" height="2" y="2"/>
            </pattern>
        </defs>
    </svg>
</div>

<script>
    /* UI variables */
    var useGradientOnTreeEdges = true;
    var useGradientOnExtraEdgesWithin = true;
    var useGradientOnExtraEdgesAcross = true;
    var selectedNodeId = null;
    var attributeForNodeSize = null;

    /* svg variables */
    var svg = d3.select("#viz").select("svg");
    var solidEdgeColor = "#555";
    var nodeHeight = 16;    // the total amount of vertical space each node takes up
    var minRadius = 4;
    var maxRadius = 8;
    var midRadius = (minRadius + maxRadius) / 2
    var nodeSizeScale;
    var hiddenNodeSet = new Set();

    /* data loading and preprocessing */
    var nodeData;   // list of nodes
    var linkData;   // list of links
    var nodeLookup = {};    // maps node id to node object for easy lookup
    var fakeRoot;   // used to store all level 0 nodes as children for easier drawing
    
    d3.json("data/nodesAndLinks.json").then(function(data) {
        nodeData = data.nodes;
        linkData = data.links;
        preprocessData(nodeData, linkData, nodeLookup);   // transform data into the format we want
        fakeRoot = transformToNested(nodeData);
        console.log(nodeData);
        Tree(fakeRoot, {
            /*label: d => d.id,*/
            width: 1000
        });
    });
    // Copyright 2021 Observable, Inc.
    // Released under the ISC license.
    // https://observablehq.com/@d3/tree
    function Tree(data, { // data is either tabular (array of objects) or hierarchy (nested objects)
        path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes
        id = Array.isArray(data) ? d => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)
        parentId = Array.isArray(data) ? d => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier
        children, // if hierarchical data, given a d in data, returns its children
        tree = d3.tree, // layout algorithm (typically d3.tree or d3.cluster)
        sort, // how to sort nodes prior to layout (e.g., (a, b) => d3.descending(a.height, b.height))
        label, // given a node d, returns the display name
        title, // given a node d, returns its hover text
        link, // given a node d, its link (if any)
        linkTarget = "_blank", // the target attribute for links (if any)
        width = 640, // outer width, in pixels
        height, // outer height, in pixels
        r = maxRadius, // radius of nodes
        padding = 1, // horizontal padding for first and last column
        fill = "#999", // fill for nodes
        fillOpacity = "0.8", // fill opacity for nodes
        stroke = "#555", // stroke for links
        strokeWidth = 2, // stroke width for links
        strokeOpacity = 0.35, // stroke opacity for links
        strokeLinejoin, // stroke line join for links
        strokeLinecap, // stroke line cap for links
        halo = "#fff", // color of label halo 
        haloWidth = 3, // padding around the labels
        } = {})
    {
        // If a path accessor is specified, we can impute the internal nodes from the slash-
        // separated path; otherwise, the tabular data must include the internal nodes, not
        // just leaves. TODO https://github.com/d3/d3-hierarchy/issues/33
        if (path != null) {
            const D = d3.map(data, d => d);
            const I = d3.map(data, path).map(d => (d = `${d}`).startsWith("/") ? d : `/${d}`);
            const paths = new Set(I);
            for (const path of paths) {
            const parts = path.split("/");
            while (parts.pop(), parts.length) {
                const path = parts.join("/") || "/";
                if (paths.has(path)) continue;
                paths.add(path), I.push(path), D.push(null);
            }
            }
            id = (_, i) => I[i];
            parentId = (_, i) => I[i] === "/" ? "" : I[i].slice(0, I[i].lastIndexOf("/")) || "/";
            data = D;
        }

        // If id and parentId options are specified (perhaps implicitly via the path option),
        // use d3.stratify to convert tabular data to a hierarchy; otherwise we assume that
        // the data is specified as an object {children} with nested objects (a.k.a. the
        // “flare.json” format), and use d3.hierarchy.
        const root = id == null && parentId == null
            ? d3.hierarchy(data, children)
            : d3.stratify().id(id).parentId(parentId)(data);

        // Compute labels and titles.
        const descendants = root.descendants();
        const L = label == null ? null : descendants.map(d => label(d.data, d));

        // Sort the nodes.
        if (sort != null) root.sort(sort);
        // Compute the layout.
        const dx = nodeHeight;
        const dy = width / (root.height + padding);
        tree().nodeSize([dx, dy])(root);

        // Center the tree.
        let x0 = Infinity;
        let x1 = -x0;
        root.each(d => {
            if (d.x > x1) x1 = d.x;
            if (d.x < x0) x0 = d.x;
        });

        // Compute the default height.
        if (height === undefined) height = x1 - x0 + dx * 2;

        svg.attr("viewBox", [-dy * padding / 2, x0 - dx, width, height])
            .attr("width", width)
            .attr("height", height)
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
            .attr("font-family", "sans-serif")
            .attr("font-size", 10);

        svg.append("g")
            .attr("fill", "none")
            .attr("stroke-opacity", strokeOpacity)
            .attr("stroke-linecap", strokeLinecap)
            .attr("stroke-linejoin", strokeLinejoin)
            .attr("stroke-width", strokeWidth)
            .selectAll("path")
            .data(root.links())
            .join("path")
            .attr("class", d => `from${d.target.data.id} to${d.source.data.id}`)
            .classed("fakeRootElements", d => d.source.data.id == "0")
            .classed("treeEdges", true)
            .attr("stroke", getGradientForTreeLink)
            .attr("id", d => "link" + d.source.data.id + "to" + d.target.data.id)
            .attr("d", computePathCommandsForTreeEdges);

        const node = svg.append("g")
            .selectAll("a")
            .data(root.descendants())
            .join("a")
            .classed("fakeRootElements", d => d.data.id == "0")
            .attr("id", d => "node" + d.data.id)
            .attr("xlink:href", link == null ? null : d => link(d.data, d))
            .attr("target", link == null ? null : linkTarget)
            .attr("transform", d => `translate(${d.y},${d.x})`);

        node.append("circle")
            .attr("id", d => "circle" + d.data.id)
            .attr("fill", fill)
            .attr("fill-opacity", fillOpacity)
            .attr("r", computeNodeRadius)
            .on("click", updateSelectedNode);

        let extraLinksBetweenNodes = getLinksBetweenNodes(root.descendants(), true, true);
        svg.append("g")
            .attr("fill", "none")
            .attr("stroke-opacity", strokeOpacity)
            .attr("stroke-linecap", strokeLinecap)
            .attr("stroke-linejoin", strokeLinejoin)
            .attr("stroke-width", strokeWidth)
            .selectAll("path")
            .data(extraLinksBetweenNodes)
            .join("path")
            .attr("class", d => `from${d.source.data.id} to${d.target.data.id}`)
            .classed("extraEdgesBetweenNodes", true)
            .classed("extraEdgesAcrossLevels", d => !d.sameLevel)
            .classed("extraEdgesWithinLevels", d => d.sameLevel)
            .attr("stroke", getGradientForLink)
            .attr("d", drawPathBetweenNodes);

        if (title != null) node.append("title")
            .text(d => title(d.data, d));

        if (L) node.append("text")
            .attr("dy", "0.32em")
            .attr("x", d => d.children ? -6 : 6)
            .attr("text-anchor", d => d.children ? "end" : "start")
            .text((d, i) => L[i])
            .call(text => text.clone(true))
            .attr("fill", "none")
            .attr("stroke", halo)
            .attr("stroke-width", haloWidth);
    }
    function updateNodeSizeAttribute(elem) {
        attributeForNodeSize = elem.value;
        if (attributeForNodeSize) {
            let dataRange = d3.extent(nodeData.map(node => {
                let parts = attributeForNodeSize.split("/");
                if (parts.length == 2) {
                    return (node[parts[0]]) / (node[parts[1]]);
                }
                return node[attributeForNodeSize];
            }));
            nodeSizeScale = d3.scaleSqrt().domain(dataRange).range([minRadius, maxRadius]);
        } else {
            nodeSizeScale = null;
        }
        updateNodeSize();
    }
    function updateNodeSize() {
        svg.selectAll("circle")
            .attr("r", computeNodeRadius);
    }
    function computeNodeRadius(d) {
        if (!attributeForNodeSize) return midRadius;
        let parts = attributeForNodeSize.split("/");
        let scaleInput = d.data[attributeForNodeSize];
        if (parts.length == 2) {
            scaleInput = (d.data[parts[0]]) / (d.data[parts[1]])
        }
        return nodeSizeScale(scaleInput);
    }
    function getLinksBetweenNodes(nodeElems, includeAllLevels=false, includeDifferentParents=false) {
        let links = [];
        let nodeElemMap = {};   // build lookup map to easily access node element by id
        nodeElems.forEach(function (node) {
            nodeElemMap[node.data.id] = node;
        });
        nodeData.forEach(function (node) {
            let nonDirectParents = node.parents.filter(nId => nId != node.directParent);   // get only the non-direct parents, which are the nodes after the first parent node
            nonDirectParents.forEach(function (parentId) {
                let parentNode = nodeLookup[parentId];
                if (includeAllLevels || node.level == parentNode.level) { // if not including all levels, get only the links between children in the same level
                    if (includeDifferentParents || node.directParent == parentNode.directParent) { // if not including nodes with different parents, get only the links between children under the same parent
                        // this node follows the parent node, so set this node as source and parent node as target
                        links.push({
                            source: nodeElemMap[node.id],
                            target: nodeElemMap[parentId],
                            sameLevel: node.level == parentNode.level
                        });
                    }
                }
            })
        });
        return links;
    }
    function computePathCommandsForTreeEdges(d) {
        let getPath = d3.linkHorizontal()
            .x(d => d.y)
            .y(d => d.x);
        let pathString = getPath(d).split("C");
        let subPathStrings = [pathString[0].split(","), pathString[1].split(",")];
        let parsedInt1 = parseFloat(subPathStrings[0][1]);
        let parsedInt2 = parseFloat(subPathStrings[1][5]);
        if (parsedInt1 == parsedInt2) { // path is a straight line, tweak it to make it not straight
            parsedInt1 -= 0.25;
            parsedInt2 += 0.25;
            subPathStrings[0][1] = parsedInt1.toString();
            subPathStrings[1][5] = parsedInt2.toString();
            pathString[0] = subPathStrings[0].join(",");
            pathString[1] = subPathStrings[1].join(",");
        }
        return pathString.join("C");
    }
    function getGradientForTreeLink(d) {
        if (!useGradientOnTreeEdges) return solidEdgeColor;
        return "url(#horizontalGradFollowedLeft)";
    }
    function getGradientForLink(d) {
        if (d.source.data.level == d.target.data.level) {  // drawing an arc since nodes are on the same level
            if (!useGradientOnExtraEdgesWithin) return solidEdgeColor;
            if (d.source.x > d.target.x) {  // the arc goes from follower to followed node downward
                return "url(#verticalGradFollowedUp)";
            } else {    // otherwise the arc goes from follower to followed node upward
                return "url(#verticalGradFollowerUp)";
            }
        } else {    // drawing an edge between different levels
            if (!useGradientOnExtraEdgesAcross) return solidEdgeColor;
            if (d.source.data.level < d.target.data.level) {   // the edge goes from an earlier level to later level
                return "url(#horizontalGradFollowerLeft)";
            } else {    // otherwise the edge goes from a later level to earlier level
                return "url(#horizontalGradFollowedLeft)";
            }
        }
    }
    function drawPathBetweenNodes(d) {
        let pathString;
        if (d.source.data.level == d.target.data.level) { 
            pathString = drawArcBetweenSameLevel(d);
        } else {
            let edgeFunct = d3.linkHorizontal()
                .x(dt => dt.y)
                .y(dt => dt.x);
            pathString = edgeFunct(d);
        }
        return pathString;
    }
    function drawArcBetweenSameLevel(d) {
        let start = d.source.x;    // X position of start node on the X axis
        let end = d.target.x;      // X position of end node
        let height = d.source.y; // this would be the same for the two points since they are in the same level
        return ['M', height, start,    // the arc starts at the coordinate x=start, y=height-30 (where the starting node is)
            'A',                            // This means we're gonna build an elliptical arc
            (start - end)/2, ',',    // Next 2 lines are the coordinates of the inflexion point. Height of this point is proportional with start - end distance
            (start - end)/2, 0, 0, ',',
            start < end ? 1 : 0, height, ',', end] // We always want the arc on top. So if end is before start, putting 0 here turn the arc upside down.
            .join(' ');
    }
    function updateEdgeColors(type) {
        if (type == "tree") {
            useGradientOnTreeEdges = useGradientOnTreeEdges ? false : true;
            svg.selectAll(".treeEdges")
                .attr("stroke", getGradientForTreeLink);
        } else if (type == "extraAcross") {
            useGradientOnExtraEdgesAcross = useGradientOnExtraEdgesAcross ? false : true;
            svg.selectAll(".extraEdgesAcrossLevels")
                .attr("stroke", getGradientForLink);
        } else {
            useGradientOnExtraEdgesWithin = useGradientOnExtraEdgesWithin ? false : true;
            svg.selectAll(".extraEdgesWithinLevels")
                .attr("stroke", getGradientForLink);
        }
    }
    function updateSelectedNode(event, d) {
        let newSelectedNodeId = d.data.id;
        if (selectedNodeId != newSelectedNodeId) {    // a new node has been selected
            d3.select("#circle" + newSelectedNodeId).classed("selectedNode", true);
            if (selectedNodeId) {
                d3.select("#circle" + selectedNodeId).classed("selectedNode", false);
            } else {
                d3.selectAll("path").classed("dimmedEdges", true);  // dim all edges if no node was previously selected
            }
            updateHighlightedEdges(selectedNodeId, newSelectedNodeId);
            selectedNodeId = newSelectedNodeId;
            let selectedNodeObj = nodeLookup[selectedNodeId];
            if (selectedNodeObj.children.length > 0) {  // nodes with no children should not be collapsed
                d3.select("#collapseExpandButton")
                    .classed("showButton", true)
                    .html(selectedNodeObj.collapsed ? "Expand selected node" : "Collapse selected node");
            }
        }
        d3.select("#idField").html(d.data.id);
        d3.select("#timestampField").html(d.data.timestamp);
        d3.select("#numLikesField").html(d.data.numLikes);
        d3.select("#numCommentsField").html(d.data.numComments);
        event.stopPropagation();
    }
    svg.on('click', function () {   // mouse click on empty space in the svg
        // deselect currently selected node
        if (selectedNodeId) {
            d3.select("#collapseExpandButton").classed("showButton", false);
            d3.select("#circle" + selectedNodeId).classed("selectedNode", false);
            selectedNodeId = null;
            d3.select("#idField").html("");
            d3.select("#timestampField").html("");
            d3.select("#numLikesField").html("");
            d3.select("#numCommentsField").html("");
            d3.selectAll(".highlightedEdges").classed("highlightedEdges", false); // dehighlight all edges if no node is selected now
            d3.selectAll(".dimmedEdges").classed("dimmedEdges", false); // undim all edges if no node is selected now
        }
    });
    function updateHighlightedEdges(oldId, newId) {
        if (oldId) {
            d3.selectAll(`.from${oldId},.to${oldId}`)
                .classed("highlightedEdges", false);
        }
        d3.selectAll(`.from${newId},.to${newId}`)
            .classed("highlightedEdges", true);
    }
    function collapseOrExpandSelectedNode() {
        let selectedNode = nodeLookup[selectedNodeId];
        if (selectedNode.children.length == 0) return;  // nodes with no children cannot be collapsed
        let newState = selectedNode.collapsed ? false : true;
        d3.select("#circle" + selectedNodeId).classed("collapsedNode", newState);
        let nodeQueue = selectedNode.children.map(childNode => childNode);  // make a shallow copy of the children nodes since we'll pop from list
        while (nodeQueue.length > 0) {
            let currNode = nodeQueue.shift();
            let currNodeId = currNode.id;
            if (!newState)  {
                hiddenNodeSet.delete(currNodeId);
                if (currNode.collapsed) {   // if expanding a node, reset a previously collapsed child's status to false
                    currNode.collapsed = false;
                    d3.select("#circle" + currNodeId).classed("collapsedNode", false);
                }
                d3.selectAll(`.from${currNodeId},.to${currNodeId}`)
                    .filter(function () {
                        let connectedNodeClasses = d3.select(this).attr("class").split(" ");
                        let fromClass = connectedNodeClasses[0];
                        let toClass = connectedNodeClasses[1];
                        let connectedToCollapsedNode = Array.from(hiddenNodeSet).find(hiddenId => fromClass.includes(hiddenId) || toClass.includes(hiddenId));
                        return connectedToCollapsedNode == undefined;
                    })
                    .classed("hiddenEdges", false);
            } else {
                hiddenNodeSet.add(currNodeId);
                d3.selectAll(`.from${currNodeId},.to${currNodeId}`)
                    .classed("hiddenEdges", true);
            }
            d3.select("#node" + currNodeId)
                .classed("hiddenNodes", newState);
            nodeQueue = nodeQueue.concat(nodeLookup[currNodeId].children.map(childNode => childNode));
        }
        d3.select("#collapseExpandButton")
            .html(newState ? "Expand selected node" : "Collapse selected node");
        selectedNode.collapsed = newState;
    }
</script>