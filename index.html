<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>

<!-- Create a div where the graph will take place -->
<div id="viz"></div>

<script>
    /* data loading and preprocessing */
    var nodeData;   // list of nodes
    var linkData;   // list of links
    var nodeLookup = {};    // maps node id to node object for easy lookup
    var rootNodes;
    d3.json("data/nodesAndLinks.json").then(function(data) {
        nodeData = data.nodes;
        linkData = data.links;
        nodeData.forEach(function (nodeObj) {
            nodeObj.parents = [];
            nodeObj.allChildren = [];
            nodeObj.otherFollowers = [];
            nodeObj.otherFollowing = [];
            nodeLookup[nodeObj.id] = nodeObj;
        });
        preprocessData();   // transform data into the format we want
        rootNodes = transformToNested();
        rootNodes.forEach(function (rootNode) {
            Tree(rootNode, {
                label: d => d.id,
                width: 1000
            });
        });
    });
    function preprocessData() {
        linkData.forEach(function (link) {
            let sourceNode = nodeLookup[link.source];   // the source node represents the user that follows the target user
            let targetNode = nodeLookup[link.target];   // the target node represents the user that is followed the source user
            if (sourceNode.timestamp > targetNode.timestamp) {
                // store the target node id as a parent of the source node only if the target node has an earlier timestamp
                sourceNode.parents.push(targetNode.id);
                targetNode.allChildren.push(sourceNode.id);
            } else {
                // otherwise still keep it, as it could be useful later
                sourceNode.otherFollowing.push(targetNode.id);
                targetNode.otherFollowers.push(sourceNode.id);
            }
        });
        nodeData.forEach(function (node) {
            node.parents.sort((a, b) => nodeLookup[a].timestamp - nodeLookup[b].timestamp);
            node.allChildren.sort((a, b) => nodeLookup[a].timestamp - nodeLookup[b].timestamp);
            node.directParent = node.parents.length > 0 ? node.parents[0] : null;    // the direct parent of the node is the node among the parents that has the earliest timestamp
        });
        computeAndAddNodeLevel();
    }
    function computeAndAddNodeLevel() {
        let level0Nodes = [];
        nodeData.forEach(function (nodeObj) {
            // TODO: figure out what to do with "loner" nodes - nodes with no parents and no children
            if (nodeObj.parents.length == 0) {
                level0Nodes.push(nodeObj);
                nodeObj.level = 0;
            }
        });
        let currLevelNodes = level0Nodes;
        let currNode = currLevelNodes.shift();
        while (currNode) {
            let currNodeLevel = currNode.level;
            let childrenNodesIds = currNode.allChildren;
            childrenNodesIds.forEach(function(id) {
                let childNodeObj = nodeLookup[id];
                if (childNodeObj.directParent == currNode.id && childNodeObj.level == undefined) {
                    childNodeObj.level = currNodeLevel + 1;
                    currLevelNodes.push(childNodeObj);
                }
            });
            currNode = currLevelNodes.shift();
        }
    }
    function transformToNested() {
        nodeData.forEach(function (node) {
            node.children = [];
            node.allChildren.forEach(function (childId) {
                let childNode = nodeLookup[childId];
                if (childNode.directParent == node.id) {
                    node.children.push(childNode);
                }
            });
        });
        let onlyRootNodes = []
        for (let i = 0; i < nodeData.length; i++) {
            if (nodeData[i].directParent == null && nodeData[i].children.length > 0) {
                onlyRootNodes.push(nodeData[i]);
            }
        }
        return onlyRootNodes;
    }
    /* end of data loading and preprocessing */

    function Tree(data, { // data is either tabular (array of objects) or hierarchy (nested objects)
        path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes
        id = Array.isArray(data) ? d => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)
        parentId = Array.isArray(data) ? d => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier
        children, // if hierarchical data, given a d in data, returns its children
        tree = d3.tree, // layout algorithm (typically d3.tree or d3.cluster)
        sort, // how to sort nodes prior to layout (e.g., (a, b) => d3.descending(a.height, b.height))
        label, // given a node d, returns the display name
        title, // given a node d, returns its hover text
        link, // given a node d, its link (if any)
        linkTarget = "_blank", // the target attribute for links (if any)
        width = 640, // outer width, in pixels
        height, // outer height, in pixels
        r = 3, // radius of nodes
        padding = 1, // horizontal padding for first and last column
        fill = "#999", // fill for nodes
        fillOpacity, // fill opacity for nodes
        stroke = "#555", // stroke for links
        strokeWidth = 1.5, // stroke width for links
        strokeOpacity = 0.4, // stroke opacity for links
        strokeLinejoin, // stroke line join for links
        strokeLinecap, // stroke line cap for links
        halo = "#fff", // color of label halo 
        haloWidth = 3, // padding around the labels
        } = {})
    {
        // If a path accessor is specified, we can impute the internal nodes from the slash-
        // separated path; otherwise, the tabular data must include the internal nodes, not
        // just leaves. TODO https://github.com/d3/d3-hierarchy/issues/33
        if (path != null) {
            const D = d3.map(data, d => d);
            const I = d3.map(data, path).map(d => (d = `${d}`).startsWith("/") ? d : `/${d}`);
            const paths = new Set(I);
            for (const path of paths) {
            const parts = path.split("/");
            while (parts.pop(), parts.length) {
                const path = parts.join("/") || "/";
                if (paths.has(path)) continue;
                paths.add(path), I.push(path), D.push(null);
            }
            }
            id = (_, i) => I[i];
            parentId = (_, i) => I[i] === "/" ? "" : I[i].slice(0, I[i].lastIndexOf("/")) || "/";
            data = D;
        }

        // If id and parentId options are specified (perhaps implicitly via the path option),
        // use d3.stratify to convert tabular data to a hierarchy; otherwise we assume that
        // the data is specified as an object {children} with nested objects (a.k.a. the
        // “flare.json” format), and use d3.hierarchy.
        const root = id == null && parentId == null
            ? d3.hierarchy(data, children)
            : d3.stratify().id(id).parentId(parentId)(data);

        // Compute labels and titles.
        const descendants = root.descendants();
        const L = label == null ? null : descendants.map(d => label(d.data, d));

        // Sort the nodes.
        if (sort != null) root.sort(sort);

        // Compute the layout.
        const dx = 10;
        const dy = width / (root.height + padding);
        tree().nodeSize([dx, dy])(root);

        // Center the tree.
        let x0 = Infinity;
        let x1 = -x0;
        root.each(d => {
            if (d.x > x1) x1 = d.x;
            if (d.x < x0) x0 = d.x;
        });

        // Compute the default height.
        if (height === undefined) height = x1 - x0 + dx * 2;

        const svg = d3.select("#viz").append("svg")
            .attr("viewBox", [-dy * padding / 2, x0 - dx, width, height])
            .attr("width", width)
            .attr("height", height)
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
            .attr("font-family", "sans-serif")
            .attr("font-size", 10);

        svg.append("g")
            .attr("fill", "none")
            .attr("stroke", stroke)
            .attr("stroke-opacity", strokeOpacity)
            .attr("stroke-linecap", strokeLinecap)
            .attr("stroke-linejoin", strokeLinejoin)
            .attr("stroke-width", strokeWidth)
            .selectAll("path")
            .data(root.links())
            .join("path")
                .attr("d", d3.linkHorizontal()
                    .x(d => d.y)
                    .y(d => d.x));

        const node = svg.append("g")
            .selectAll("a")
            .data(root.descendants())
            .join("a")
            .attr("xlink:href", link == null ? null : d => link(d.data, d))
            .attr("target", link == null ? null : linkTarget)
            .attr("transform", d => `translate(${d.y},${d.x})`);

        node.append("circle")
            .attr("fill", d => d.children ? stroke : fill)
            .attr("r", r);

        if (title != null) node.append("title")
            .text(d => title(d.data, d));

        if (L) node.append("text")
            .attr("dy", "0.32em")
            .attr("x", d => d.children ? -6 : 6)
            .attr("text-anchor", d => d.children ? "end" : "start")
            .text((d, i) => L[i])
            .call(text => text.clone(true))
            .attr("fill", "none")
            .attr("stroke", halo)
            .attr("stroke-width", haloWidth);
    }
</script>