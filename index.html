<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>
<script src="scripts/preprocess.js"></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
<style>
    body {
        margin: 5px;
    }
    .sidebar {
        font-family: 'Montserrat', sans-serif;
        width: auto;
        display: inline-block;
        background: #dddddd;
        border: 2px solid black;
        border-radius: 5px;
        height: fit-content;
    }
    .vizOptionsContainer {
        margin: 10px;
        padding: 5px;
        font-size: 12px;
    }
    .vizOptionsContainer button {
        font-family: 'Montserrat', sans-serif;
        font-size: 12px;
    }
    .vizOptionsContainer button:disabled {
        opacity: 1;
    }
    .vizOptionsContainer p {
        margin: 0 0 5px 0;
        font-size: 10px;
        font-style: italic;
    }
    .singleOption {
        display: flex;
        margin: 2px 0px;
    }
    .singleOption label {
        margin-left: 3px;
    }
    #tooltip {		
        text-align: left;			
        width: auto;				
        height: auto;					
        padding: 5px 10px;				
        font-size: 12px;		
        background: lightsteelblue;		
        pointer-events: none;
    }
    #complete_viz {
        display: inline-block;
        height: 100vh;
        max-height: 100vh;
        /*grid-template-columns: 1fr;
        grid-template-rows: .7fr 0.1fr .3fr;*/
    }
    #viz {
        /*overflow: scroll;*/
        position: relative;
    }
    #legend {
        position: absolute;
        right: 0;
        bottom: 0;
        background: white;
        border: 2px solid black;
        border-radius: 4px;
        padding: 0.5em;
        margin: 0.5em;
        font-family: 'Montserrat', sans-serif;
        font-size: 11px;
        text-align: left;
        width: 360px;
    }
    .graphicWrapper {
        width: 3em;
        height: 100%;
        float: left;
    }
    #nodeLegend {
        margin: auto;
        height: 1em;
        width: 1em;
        background-color: #999;
        border-radius: 50%;
    }
    #followerLegend {
        width: 1.5em;
        height: 0.2em;
        margin: 0.5em 0.5em 0.3em auto;
        background-color: blue;
    }
    #followedLegend {
        width: 1.5em;
        height: 0.2em;
        margin: 0.5em 0.5em 0.3em auto;
        background-color: red;
    }
    .fakeRootElements {
        visibility: hidden;
    }
    .selectedNode {
        stroke: black !important;
        stroke-width: 2px;
        fill-opacity: 1;
    }
    .collapsedNode {
        stroke: #999;
        fill: url(#patternCheckers);
        stroke-width: 2px;
        fill-opacity: 1;
    }
    .checker {
        fill: #777;
    }
    .dimmedEdges {
        stroke-opacity: 0.1;
    }
    .highlightedEdges {
        stroke-opacity: 0.8;
    }
    .showButton {
        visibility: visible !important;
    }
    .hiddenNodes {
        visibility: hidden !important;
    }
    .hiddenEdges {
        visibility: hidden !important;
    }
    div.tooltipBars {	
        position: absolute;			
        text-align: center;				
        padding: 2px;				
        font: 12px sans-serif;		
        background: #3F51B5;	
        border: 0px;		
        border-radius: 8px;			
        pointer-events: none;
        overflow: hidden;
        color: white;
        font-weight:600;
        font-family: Open Sans;			
    }
    .attributeContainer {
        width: 100%;
    }
    .attributeLabel {
        width: 80px;
        display: inline;
    }
    .attributeValue {
        display: inline;
    }

    #bar_chart_viz {
        user-select: none;
    }

    #goBackButton{
        margin: 0;
        position: relative;
        left: 50%;
        -ms-transform: translate(-50%, -50%);
        transform: translate(-50%, -50%);
        background-color: darkblue;
        border: none;
        color: white;
        padding: 8px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        border-radius: 6px;
    }

    button:disabled {
        opacity: 0.3;
    }

    #complete_tool{
        display: grid;
        grid-template-columns: 1fr 2fr;
    }


</style>
<div id='complete_tool'>
<div class="sidebar" id="sidebarTool">
    <div class="vizOptionsContainer">
        <div>Use divergent coloring on</div>
        <div class="networkVizOptions">
            <div class="singleOption">
                <input type="checkbox" name="treeEdgeColoring" onclick="updateEdgeColors('tree')" checked>
                <label for="treeEdgeColoring">tree edges</label>
            </div>
            <div class="singleOption">
                <input type="checkbox" name="extraEdgeAcrossColoring" onclick="updateEdgeColors('extraWithin')" checked>
                <label for="extraEdgeAcrossColoring">non-tree edges within the same level</label>
            </div>
            <div class="singleOption">
                <input type="checkbox" name="extraEdgeAcrossColoring" onclick="updateEdgeColors('extraAcross')" checked>
                <label for="extraEdgeAcrossColoring">non-tree edges across different levels</label>
            </div>
        </div>
    </div>
    <div class="vizOptionsContainer">
        <div>Vary node size by</div>
        <div class="networkVizOptions">
            <div class="singleOption">
                <input type="radio" id="incomingEdges" name="nodeSizeAttribute" value="incomingEdges" onclick="updateNodeSizeAttribute(this)">
                <label for="incomingEdges">number of incoming edges</label>
            </div>
            <div class="singleOption">
                <input type="radio" id="outgoingEdges" name="nodeSizeAttribute" value="outgoingEdges" onclick="updateNodeSizeAttribute(this)">
                <label for="outgoingEdges">number of outgoing edges</label>
            </div>
            <div class="singleOption">
                <input type="radio" id="numLikes" name="nodeSizeAttribute" value="numLikes" onclick="updateNodeSizeAttribute(this)">
                <label for="numLikes">number of likes</label>
            </div>
            <div class="singleOption">
                <input type="radio" id="numComments" name="nodeSizeAttribute" value="numComments" onclick="updateNodeSizeAttribute(this)">
                <label for="numComments">number of comments</label>
            </div>
            <div class="singleOption">
                <input type="radio" id="likesCommentsRatio" name="nodeSizeAttribute" value="numComments/numLikes" onclick="updateNodeSizeAttribute(this)">
                <label for="likesCommentsRatio">comments / likes</label>
            </div>
            <div class="singleOption">
                <input type="radio" id="uniformNodeSize" name="nodeSizeAttribute" value="" onclick="updateNodeSizeAttribute(this)" checked>
                <label for="uniformNodeSize">use uniform size</label>
            </div>
        </div>
    </div>
    <div class="vizOptionsContainer">
        <p>Click on a non-leaf node to select it, and then click the button below to collapse or expand the node</p>
        <button id="collapseExpandButton" onclick="collapseOrExpandSelectedNode()" disabled>Select a node to collapse</button>
    </div>
    <div class="vizOptionsContainer">
        <p>The selected node's information is displayed below</p>
        <div id="tooltip">
            <div class="attributeContainer">
                <div class="attributeLabel">Node ID:</div>
                <div class="attributeValue" id="idField">###</div>
            </div>
            <div class="attributeContainer">
                <div class="attributeLabel">Timestamp:</div>
                <div class="attributeValue" id="timestampField">###</div>
            </div>
            <div class="attributeContainer">
                <div class="attributeLabel">Number of Likes:</div>
                <div class="attributeValue" id="numLikesField">###</div>
            </div>
            <div class="attributeContainer">
                <div class="attributeLabel">Number of Comments:</div>
                <div class="attributeValue" id="numCommentsField">###</div>
            </div>
            <div class="attributeContainer">
                <div class="attributeLabel">Degree of Contribution:</div>
                <div class="attributeValue" id="degContributionField">###</div>
            </div>
        </div>
    </div>

    <div id='bar_chart_div'>
        <div id="bar_chart_viz"></div>
        <div id="bar_chart_controls">
            <button onClick="goBack(this)" id="goBackButton" disabled>Go Back</button>
        </div>
    </div>
</div>
<div id="complete_viz">
<!-- Create a div where the graph will take place -->
    <div id="viz">
        <svg id="network">
            <defs>
                <linearGradient id="verticalGradFollowedUp" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
                    <stop offset="100%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
                </linearGradient>
                <linearGradient id="verticalGradFollowerUp" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
                    <stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
                </linearGradient>
                <linearGradient id="horizontalGradFollowedLeft" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
                    <stop offset="100%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
                </linearGradient>
                <linearGradient id="horizontalGradFollowerLeft" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
                    <stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
                </linearGradient>
                <pattern id="patternCheckers" x="0" y="0" width="4" height="4" patternUnits="userSpaceOnUse" >
                    <rect class="checker" x="0" width="2" height="2" y="0"/>
                    <rect class="checker" x="2" width="2" height="2" y="2"/>
                </pattern>
            </defs>
        </svg>
        <div id="legend">
            <div style="text-align: center;">Legend</div>
            <div class="legendItem">
                <div class="graphicWrapper">
                    <div class="legendGraphic" id="nodeLegend"></div>
                </div>
                <div class="legendText">A user who has posted the viral hashtag</div>
            </div>
            <div class="legendItem">
                <div class="graphicWrapper">
                    <div class="legendGraphic" id="followerLegend"></div>
                </div>
                <div class="legendText">End of edge connected to the user following another user</div>
            </div>
            <div class="legendItem">
                <div class="graphicWrapper">
                    <div class="legendGraphic" id="followedLegend"></div>
                </div>
                <div class="legendText">End of edge connected to the user being followed</div>
            </div>
        </div>
    </div>
</div>
</div>

<script>
    /* UI variables */
    var sidebarWidth = document.getElementById('sidebarTool').clientWidth;
    var windowWidth = window.innerWidth;
    var networkGraphWidth = document.getElementById('complete_viz').clientWidth////windowWidth - d3.select("#complete_tool").node().getBoundingClientRect().width - 15;
    var windowHeight = window.innerHeight;
    var networkGraphHeight = document.getElementById('complete_viz').clientHeight - 20;//windowHeight * 0.95;
    var barGraphHeight = windowHeight * 0.3;
    var useGradientOnTreeEdges = true;
    var useGradientOnExtraEdgesWithin = true;
    var useGradientOnExtraEdgesAcross = true;
    var selectedNodeId = null;
    var attributeForNodeSize = null;

    let selectedNodesIds = []

    /*Bar chart variables*/
    let bar_svg = null
    let timestamps = []
    let updatableData = []
    let curr_time_measures = {}
    let xAxisLabel = ""

    /* svg variables */
    var svg = d3.select("#viz").select("svg");
    var solidEdgeColor = "#555";
    var nodeHeight = 16;    // the total amount of vertical space each node takes up
    var minRadius = 4;
    var maxRadius = 8;
    var midRadius = (minRadius + maxRadius) / 2
    var nodeSizeScale;
    var hiddenNodeSet = new Set();
    var collapsedNodeSet = new Set();

    /* data loading and preprocessing */
    var nodeData;   // list of nodes
    var linkData;   // list of links
    var nodeLookup = {};    // maps node id to node object for easy lookup
    var fakeRoot;   // used to store all level 0 nodes as children for easier drawing
    
    d3.json("data/nodesAndLinks.json").then(function(data) {
        nodeData = data.nodes;
        linkData = data.links;
        preprocessData(nodeData, linkData, nodeLookup);   // transform data into the format we want
        nodeData.forEach(item => item.timestamp = item.timestamp*1000) //get rid of this line later, we expect the timestamp to be in millis by default
        fakeRoot = transformToNested(nodeData);
        console.log(nodeData);
        computeDegreeOfContributionForAllNodes(nodeData, nodeLookup);
        Tree(fakeRoot, {
            /*label: d => d.id,*/
            width: networkGraphWidth,
            height : networkGraphHeight
        });
        console.log(fakeRoot)
        getTimeStamps(fakeRoot)
    });
    // Copyright 2021 Observable, Inc.
    // Released under the ISC license.
    // https://observablehq.com/@d3/tree
    function Tree(data, { // data is either tabular (array of objects) or hierarchy (nested objects)
        path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes
        id = Array.isArray(data) ? d => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)
        parentId = Array.isArray(data) ? d => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier
        children, // if hierarchical data, given a d in data, returns its children
        tree = d3.tree, // layout algorithm (typically d3.tree or d3.cluster)
        sort, // how to sort nodes prior to layout (e.g., (a, b) => d3.descending(a.height, b.height))
        label, // given a node d, returns the display name
        title, // given a node d, returns its hover text
        link, // given a node d, its link (if any)
        linkTarget = "_blank", // the target attribute for links (if any)
        width = 640, // outer width, in pixels
        height, // outer height, in pixels
        r = maxRadius, // radius of nodes
        padding = 0.25, // horizontal padding for first and last column
        fill = "#999", // fill for nodes
        fillOpacity = "0.8", // fill opacity for nodes
        stroke = "#555", // stroke for links
        strokeWidth = 2, // stroke width for links
        strokeOpacity = 0.35, // stroke opacity for links
        strokeLinejoin, // stroke line join for links
        strokeLinecap, // stroke line cap for links
        halo = "#fff", // color of label halo 
        haloWidth = 3, // padding around the labels
        } = {})
    {
        // If a path accessor is specified, we can impute the internal nodes from the slash-
        // separated path; otherwise, the tabular data must include the internal nodes, not
        // just leaves. TODO https://github.com/d3/d3-hierarchy/issues/33
        if (path != null) {
            const D = d3.map(data, d => d);
            const I = d3.map(data, path).map(d => (d = `${d}`).startsWith("/") ? d : `/${d}`);
            const paths = new Set(I);
            for (const path of paths) {
            const parts = path.split("/");
            while (parts.pop(), parts.length) {
                const path = parts.join("/") || "/";
                if (paths.has(path)) continue;
                paths.add(path), I.push(path), D.push(null);
            }
            }
            id = (_, i) => I[i];
            parentId = (_, i) => I[i] === "/" ? "" : I[i].slice(0, I[i].lastIndexOf("/")) || "/";
            data = D;
        }

        // If id and parentId options are specified (perhaps implicitly via the path option),
        // use d3.stratify to convert tabular data to a hierarchy; otherwise we assume that
        // the data is specified as an object {children} with nested objects (a.k.a. the
        // “flare.json” format), and use d3.hierarchy.
        const root = id == null && parentId == null
            ? d3.hierarchy(data, children)
            : d3.stratify().id(id).parentId(parentId)(data);

        // Compute labels and titles.
        const descendants = root.descendants();
        const L = label == null ? null : descendants.map(d => label(d.data, d));

        // Sort the nodes.
        if (sort != null) root.sort(sort);
        // Compute the layout.
        const dx = nodeHeight;
        const dy = width / (root.height + padding);
        tree().nodeSize([dx, dy])(root);


        // Center the tree.
        let x0 = Infinity;
        let x1 = -x0;
        root.each(d => {
            if (d.x > x1) x1 = d.x;
            if (d.x < x0) x0 = d.x;
        });

        let height_mult = (x1 - x0 + dx * 2)/(height)
        // Compute the default height.
        if (height === undefined) height = x1 - x0 + dx * 2;

        svg.attr("viewBox", [-dy * padding / 2, x0 - dx, width, height*height_mult])
            .attr("width", width)
            .attr("height", height)
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
            .attr("font-family", "sans-serif")
            .attr("font-size", 10);

        svg.append("g")
            .attr("fill", "none")
            .attr("stroke-opacity", strokeOpacity)
            .attr("stroke-linecap", strokeLinecap)
            .attr("stroke-linejoin", strokeLinejoin)
            .attr("stroke-width", strokeWidth)
            .selectAll("path")
            .data(root.links())
            .join("path")
            .attr("class", d => `from${d.target.data.id} to${d.source.data.id}`)
            .classed("fakeRootElements", d => d.source.data.id == "0")
            .classed("treeEdges", true)
            .attr("stroke", getGradientForTreeLink)
            .attr("id", d => "link" + d.target.data.id + "to" + d.source.data.id)
            .attr("d", computePathCommandsForTreeEdges);

        const node = svg.append("g")
            .selectAll("a")
            .data(root.descendants())
            .join("a")
            .classed("fakeRootElements", d => d.data.id == "0")
            .attr("id", d => "node" + d.data.id)
            .attr("xlink:href", link == null ? null : d => link(d.data, d))
            .attr("target", link == null ? null : linkTarget)
            .attr("transform", d => `translate(${d.y},${d.x})`);

        node.append("circle")
            .attr("id", d => "circle" + d.data.id)
            .attr("fill", fill)
            .attr("fill-opacity", fillOpacity)
            .attr("r", computeNodeRadius)
            .on("click", updateSelectedNode);

        let extraLinksBetweenNodes = getLinksBetweenNodes(root.descendants(), true, true);
        svg.append("g")
            .attr("fill", "none")
            .attr("stroke-opacity", strokeOpacity)
            .attr("stroke-linecap", strokeLinecap)
            .attr("stroke-linejoin", strokeLinejoin)
            .attr("stroke-width", strokeWidth)
            .selectAll("path")
            .data(extraLinksBetweenNodes)
            .join("path")
            .attr("class", d => `from${d.source.data.id} to${d.target.data.id}`)
            .classed("extraEdgesBetweenNodes", true)
            .classed("extraEdgesAcrossLevels", d => !d.sameLevel)
            .classed("extraEdgesWithinLevels", d => d.sameLevel)
            .attr("stroke", getGradientForLink)
            .attr("id", d => "link" + d.source.data.id + "to" + d.target.data.id)
            .attr("d", drawPathBetweenNodes);

        if (title != null) node.append("title")
            .text(d => title(d.data, d));

        if (L) node.append("text")
            .attr("dy", "0.32em")
            .attr("x", d => d.children ? -6 : 6)
            .attr("text-anchor", d => d.children ? "end" : "start")
            .text((d, i) => L[i])
            .call(text => text.clone(true))
            .attr("fill", "none")
            .attr("stroke", halo)
            .attr("stroke-width", haloWidth);
    }
    function updateNodeSizeAttribute(elem) {
        attributeForNodeSize = elem.value;
        if (attributeForNodeSize == "incomingEdges") {
            let dataRange = d3.extent(nodeData.map(node => node.allChildren.length));
            nodeSizeScale = d3.scaleSqrt().domain(dataRange).range([minRadius, maxRadius]);
        } else if (attributeForNodeSize == "outgoingEdges") {
            let dataRange = d3.extent(nodeData.map(node => node.parents.length));
            nodeSizeScale = d3.scaleSqrt().domain(dataRange).range([minRadius, maxRadius]);
        } else if (attributeForNodeSize) {
            let dataRange = d3.extent(nodeData.map(node => {
                let parts = attributeForNodeSize.split("/");
                if (parts.length == 2) {
                    return (node[parts[0]]) / (node[parts[1]]);
                }
                return node[attributeForNodeSize];
            }));
            nodeSizeScale = d3.scaleSqrt().domain(dataRange).range([minRadius, maxRadius]);
        } else {
            nodeSizeScale = null;
        }
        updateNodeSize();
    }
    function updateNodeSize() {
        svg.selectAll("circle")
            .attr("r", computeNodeRadius);
    }
    function computeNodeRadius(d) {
        if (!attributeForNodeSize || d.data.id == "0") return midRadius;
        let parts = attributeForNodeSize.split("/");
        let scaleInput;
        if (attributeForNodeSize == "incomingEdges") {
            scaleInput = d.data.allChildren.length;
        } else if (attributeForNodeSize == "outgoingEdges") {
            scaleInput = d.data.parents.length;
        } else if (parts.length == 2) {
            scaleInput = (d.data[parts[0]]) / (d.data[parts[1]])
        } else {
            scaleInput = d.data[attributeForNodeSize]
        }
        return nodeSizeScale(scaleInput);
    }
    function getLinksBetweenNodes(nodeElems, includeAllLevels=false, includeDifferentParents=false) {
        let links = [];
        let nodeElemMap = {};   // build lookup map to easily access node element by id
        nodeElems.forEach(function (node) {
            nodeElemMap[node.data.id] = node;
        });
        nodeData.forEach(function (node) {
            let nonDirectParents = node.parents.filter(nId => nId != node.directParent);   // get only the non-direct parents, which are the nodes after the first parent node
            nonDirectParents.forEach(function (parentId) {
                let parentNode = nodeLookup[parentId];
                if (includeAllLevels || node.level == parentNode.level) { // if not including all levels, get only the links between children in the same level
                    if (includeDifferentParents || node.directParent == parentNode.directParent) { // if not including nodes with different parents, get only the links between children under the same parent
                        // this node follows the parent node, so set this node as source and parent node as target
                        links.push({
                            source: nodeElemMap[node.id],
                            target: nodeElemMap[parentId],
                            sameLevel: node.level == parentNode.level
                        });
                    }
                }
            })
        });
        return links;
    }
    function computePathCommandsForTreeEdges(d) {
        let getPath = d3.linkHorizontal()
            .x(d => d.y)
            .y(d => d.x);
        let pathString = getPath(d).split("C");
        let subPathStrings = [pathString[0].split(","), pathString[1].split(",")];
        let parsedInt1 = parseFloat(subPathStrings[0][1]);
        let parsedInt2 = parseFloat(subPathStrings[1][5]);
        if (parsedInt1 == parsedInt2) { // path is a straight line, tweak it to make it not straight
            parsedInt1 -= 0.25;
            parsedInt2 += 0.25;
            subPathStrings[0][1] = parsedInt1.toString();
            subPathStrings[1][5] = parsedInt2.toString();
            pathString[0] = subPathStrings[0].join(",");
            pathString[1] = subPathStrings[1].join(",");
        }
        return pathString.join("C");
    }
    function getGradientForTreeLink(d) {
        if (!useGradientOnTreeEdges) return solidEdgeColor;
        return "url(#horizontalGradFollowedLeft)";
    }
    function getGradientForLink(d) {
        if (d.source.data.level == d.target.data.level) {  // drawing an arc since nodes are on the same level
            if (!useGradientOnExtraEdgesWithin) return solidEdgeColor;
            if (d.source.x > d.target.x) {  // the arc goes from follower to followed node downward
                return "url(#verticalGradFollowedUp)";
            } else {    // otherwise the arc goes from follower to followed node upward
                return "url(#verticalGradFollowerUp)";
            }
        } else {    // drawing an edge between different levels
            if (!useGradientOnExtraEdgesAcross) return solidEdgeColor;
            if (d.source.data.level < d.target.data.level) {   // the edge goes from an earlier level to later level
                return "url(#horizontalGradFollowerLeft)";
            } else {    // otherwise the edge goes from a later level to earlier level
                return "url(#horizontalGradFollowedLeft)";
            }
        }
    }
    function drawPathBetweenNodes(d) {
        let pathString;
        if (d.source.data.level == d.target.data.level) { 
            pathString = drawArcBetweenSameLevel(d);
        } else {
            let edgeFunct = d3.linkHorizontal()
                .x(dt => dt.y)
                .y(dt => dt.x);
            pathString = edgeFunct(d);
        }
        return pathString;
    }
    function drawArcBetweenSameLevel(d) {
        let start = d.source.x;    // X position of start node on the X axis
        let end = d.target.x;      // X position of end node
        let height = d.source.y; // this would be the same for the two points since they are in the same level
        return ['M', height, start,    // the arc starts at the coordinate x=start, y=height-30 (where the starting node is)
            'A',                            // This means we're gonna build an elliptical arc
            (start - end)/4, ',',    // Next 2 lines are the coordinates of the inflexion point. Height of this point is proportional with start - end distance
            (start - end)/2, 0, 0, ',',
            start < end ? 1 : 0, height, ',', end] // We always want the arc on top. So if end is before start, putting 0 here turn the arc upside down.
            .join(' ');
    }
    function updateEdgeColors(type) {
        if (type == "tree") {
            useGradientOnTreeEdges = useGradientOnTreeEdges ? false : true;
            svg.selectAll(".treeEdges")
                .attr("stroke", getGradientForTreeLink);
        } else if (type == "extraAcross") {
            useGradientOnExtraEdgesAcross = useGradientOnExtraEdgesAcross ? false : true;
            svg.selectAll(".extraEdgesAcrossLevels")
                .attr("stroke", getGradientForLink);
        } else {
            useGradientOnExtraEdgesWithin = useGradientOnExtraEdgesWithin ? false : true;
            svg.selectAll(".extraEdgesWithinLevels")
                .attr("stroke", getGradientForLink);
        }
    }
    function updateSelectedNode(event, d) {
        selectedNodesIds.forEach(id => {
            d3.select("#circle" + id).classed("selectedNode", false);
            d3.selectAll(`.from${id},.to${id}`)
                .classed("highlightedEdges", false);
        })
        let newSelectedNodeId = d.data.id;
        if (selectedNodeId != newSelectedNodeId) {    // a new node has been selected
            d3.select("#circle" + newSelectedNodeId).classed("selectedNode", true);
            if (selectedNodeId) {
                d3.select("#circle" + selectedNodeId).classed("selectedNode", false);
            } else {
                d3.selectAll("path").classed("dimmedEdges", true);  // dim all edges if no node was previously selected
            }
            updateHighlightedEdges(selectedNodeId, newSelectedNodeId);
            selectedNodeId = newSelectedNodeId;
            let selectedNodeObj = nodeLookup[selectedNodeId];
            d3.select("#collapseExpandButton")
                .classed("showButton", true)
                .html(selectedNodeObj.collapsed ? "Expand selected node" : "Collapse selected node")
                .attr("disabled", selectedNodeObj.children.length > 0 ? null : "");
        }
        d3.select("#idField").html(d.data.id);
        d3.select("#timestampField").html(d.data.timeString);
        d3.select("#numLikesField").html(d.data.numLikes);
        d3.select("#numCommentsField").html(d.data.numComments);
        d3.select("#degContributionField").html(d.data.degOfContribution);
        event.stopPropagation();
    }
    svg.on('click', function () {   // mouse click on empty space in the svg
        // deselect currently selected node
        if (selectedNodeId) {
            deselectSelectedNodes()
        }
    });

    function deselectSelectedNodes(){
        d3.select("#collapseExpandButton").classed("showButton", false);
        d3.select("#circle" + selectedNodeId).classed("selectedNode", false);
        selectedNodeId = null;
        selectedNodesIds.forEach(id => {
            d3.select("#circle" + id).classed("selectedNode", false);
            d3.selectAll(`.from${id},.to${id}`)
                .classed("highlightedEdges", false);
        })
        selectedNodesIds.length = 0
        d3.select("#idField").html("");
        d3.select("#timestampField").html("");
        d3.select("#numLikesField").html("");
        d3.select("#numCommentsField").html("");
        d3.select("#degContributionField").html("");
        d3.selectAll(".highlightedEdges").classed("highlightedEdges", false); // dehighlight all edges if no node is selected now
        d3.selectAll(".dimmedEdges").classed("dimmedEdges", false); // undim all edges if no node is selected now
    }

    function updateHighlightedEdges(oldId, newId) {
        if (oldId) {
            d3.selectAll(`.from${oldId},.to${oldId}`)
                .classed("highlightedEdges", false);
        }
        d3.selectAll(`.from${newId},.to${newId}`)
            .classed("highlightedEdges", true);
    }
    function collapseOrExpandSelectedNode() {
        let selectedNode = nodeLookup[selectedNodeId];
        if (selectedNode.children.length == 0) return;  // nodes with no children cannot be collapsed, so do nothing
        let newStateIsCollapse = selectedNode.collapsed ? false : true; // true if node was previously not collapsed, and false if node was previously collapsed
        d3.select("#circle" + selectedNodeId).classed("collapsedNode", newStateIsCollapse); // apply, or remove, the collpasedNode class
        if (newStateIsCollapse) {
            collapsedNodeSet.add(selectedNodeId);
        } else {
            collapsedNodeSet.delete(selectedNodeId);
        }
        // we only want to hide or unhide a child node if it has no other parents than the selected node
        //let nodeQueue = selectedNode.children.map(childNode => childNode);
        let nodeQueue = selectedNode.allChildren.map(childId => nodeLookup[childId]);
        //let nodeQueue = allChildrenNodes.filter(childNode => childNode.parents.length == 1);  // make a shallow copy of the children nodes since we'll pop from list
        while (nodeQueue.length > 0) {  // recursively go through the children nodes to update them
            let currNode = nodeQueue.shift();
            let currNodeId = currNode.id;
            if (!newStateIsCollapse)  { // if we're expanding the selected node
                hiddenNodeSet.delete(currNodeId);   // remove this child node from the hidden node list, if it's previously hidden
                if (currNode.collapsed) {   // if expanding a node, reset a previously collapsed child's status to false
                    currNode.collapsed = false;
                    d3.select("#circle" + currNodeId).classed("collapsedNode", false);
                }
                d3.selectAll(`.from${currNodeId},.to${currNodeId}`) // select all the edges associated with this child node
                    .filter(function () {                           // and keep only the edges not connected to a hidden or collapsed node
                        let connectedNodeClasses = d3.select(this).attr("class").split(" ");
                        let fromClass = connectedNodeClasses[0];
                        let toClass = connectedNodeClasses[1];
                        let connectedToHiddenNode = Array.from(hiddenNodeSet).some(hiddenId => fromClass.includes(hiddenId) || toClass.includes(hiddenId));
                        let connectedToCollapsedNode = Array.from(collapsedNodeSet).find(collapsedId => fromClass.includes(collapsedId) || toClass.includes(collapsedId));
                        return !connectedToHiddenNode && !connectedToCollapsedNode;
                    })
                    .classed("hiddenEdges", false);
                d3.select("#node" + currNodeId)
                    .classed("hiddenNodes", false);
            } else {    // if we're collapsing the selected node
                let nodeHasUncollapsedParents = currNode.parents.some(parentId => !hiddenNodeSet.has(parentId) && !collapsedNodeSet.has(parentId));
                if (!nodeHasUncollapsedParents) {   // only hide this child node if it all its parents are hidden or collapsed
                    hiddenNodeSet.add(currNodeId);
                    d3.selectAll(`.from${currNodeId},.to${currNodeId}`)
                        .classed("hiddenEdges", true);
                    d3.select("#node" + currNodeId)
                        .classed("hiddenNodes", true);
                } else {    // if we're not hiding this child node, we still need to hide the edges from it to all currently collapsed nodes, if any
                    Array.from(collapsedNodeSet).forEach(function (collapsedNodeId) {
                        let nodes = d3.select(`#link${currNodeId}to${collapsedNodeId}`)
                            .classed("hiddenEdges", true);
                    })
                }
            }
            // we only want to hide or unhide a child node if it has no other parents than the selected node
            //nodeQueue = nodeQueue.concat(nodeLookup[currNodeId].children.map(childNode => childNode));
            nodeQueue = nodeQueue.concat(nodeLookup[currNodeId].allChildren.map(childId => nodeLookup[childId]));
        }
        d3.select("#collapseExpandButton")
            .html(newStateIsCollapse ? "Expand selected node" : "Collapse selected node");
        selectedNode.collapsed = newStateIsCollapse;
    }

    function getTimeStamps(root){
        tree = d3.hierarchy(root)
        tree.eachBefore(node =>{
            time = node.data.timestamp
            if (time !== undefined){
                let datetime = new Date(time)
                let date = datetime.getDate()
                let month = datetime.getMonth()
                let year = datetime.getFullYear()
                let hour = datetime.getHours()
                let min = datetime.getMinutes()
                let seconds = datetime.getSeconds() 
                timestamps.push(
                    {
                        'timestamp': time,
                        'year': year,
                        'month': month,
                        'date': date,
                        'hour': hour,
                        'min': min,
                        'seconds': seconds,
                        'nodeId': node.data.id
                    }
                )
            }
        })

        //nodeData is already sorted with respect to timestamp. So, timestamp is sorted too
        console.log(timestamps)
        getTimeStampByDate(timestamps, updatableData)
        bar_svg = drawBarSvg()
        drawBars(timestamps, updatableData, bar_svg)
        // setInterval(()=>{
        //     getTimeStampByHour(timestamps, updatableData, 2,5,2020)
        //     svg.selectAll('g').remove()
        //     drawBars(timestamps, updatableData, svg)
        // }, 3000)
    }

    function drawBarSvg(){
        // let width = document.getElementById('bar_chart_div').clientWidth
        // let height = document.getElementById('bar_chart_div').clientHeight
        let width = sidebarWidth;//document.getElementById('bar_chart_div').clientWidth
        let height = barGraphHeight;//document.getElementById('bar_chart_div').clientHeight

        console.log(width+" "+height)

        let svg = d3.select("#bar_chart_viz")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .attr('id', 'time_bars')
            
        return svg;
    }

    function drawBars(originalData, data, svg){
        let width = sidebarWidth;//document.getElementById('bar_chart_div').clientWidth
        let height = barGraphHeight;//document.getElementById('bar_chart_div').clientHeight

        let xVal = d => d.xLabel
        let yVal = d => d.count

        let margin = {top: height*0.1, bottom: height*0.5, left: width*0.1, right: width*0.1}
        let innerWidth = width - margin.left - margin.right
        let innerHeight = height - margin.top - margin.bottom

        let xScale = d3.scaleBand()
            .domain(data.map(d=>d.xLabel))
            .range([0, innerWidth])
            .padding(0.05)

        let maxCount = d3.max(data, d=> d.count)
        let yScale = d3.scaleLinear()
            .domain([0, maxCount])
            .range([innerHeight, 0])

        let tooltipBars = d3.select("#bar_chart_div").append("div")	
            .attr("class", "tooltipBars")				
            .style("opacity", 0);

        // let svg = d3.select("body")
        //     .append("svg")
        //     .attr("width", width)
        //     .attr("height", height)
        //     .attr('id', 'time_bars')

        let g = svg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`)

        g.append('g').call(d3.axisBottom(xScale))
            .attr('transform', `translate(0, ${innerHeight})`)
            .selectAll("text")
            .attr("transform", "translate(-10,0)rotate(-45)")
            .style("text-anchor", "end");
        g.append('g').call(d3.axisLeft(yScale)
            .tickSize(-innerWidth)
            .tickFormat(d3.format("d"))
            .ticks(maxCount>10?10:maxCount))
            .selectAll(".tick, .domain")
            .attr("stroke-opacity", 0.2)

        
        
        console.log(yScale(59))

        console.log(data)

        // let timeBars = document.getElementById('time_bars')
        // let svgBox = timeBars.viewBox.baseVal;
        // console.log(svgBox)

        let dataBars = g.selectAll('rect').data(data, d=>d.id)

        dataBars.enter().append('rect').merge(dataBars)
            .attr('x', d => xScale(xVal(d)))
            .attr('width', xScale.bandwidth())
            .attr('y', d => yScale(yVal(d)))
            .attr('height', d => innerHeight - yScale(yVal(d)))
            .attr("id", (d) => { return "data"+d.id})
            .style('fill', 'steelblue')
            .style("opacity", '0.8')
            .on("mousemove", function(e,d) {
                d3.select(`#data${d.id}`)
                    .style("opacity", 1)
                tooltipBars.transition()		
                    .duration(200)		
                    .style("opacity", .9);		
                tooltipBars.html(`Count: ${d.count}`)	
                    .style("left", (e.x + 10) + "px")		
                    .style("top", (e.y + 10) + "px");	
            })
            .on("mouseout", function(e,d) {	
                d3.select(`#data${d.id}`)
                    .style("opacity", '0.8')
                tooltipBars.transition()		
                    .duration(500)		
                    .style("opacity", 0);	
                })
            .on("dblclick", function(e,d){
                timestamp = d.timestamps[0]
                if(d.measure === 'min') return
                if(d.measure === "day"){
                    document.getElementById('goBackButton').disabled = false;
                    getTimeStampByHour(timestamps, data, timestamp.date,timestamp.month,timestamp.year)
                    curr_time_measures = {measure: "hour", date: timestamp.date, month: timestamp.month,year: timestamp.year}
                }else if(d.measure === "hour"){
                    getTimeStampByMinute(timestamps, data, timestamp.hour, timestamp.date,timestamp.month,timestamp.year)
                    curr_time_measures = {measure: "min", date: timestamp.date, month: timestamp.month,year: timestamp.year}
                }
                selectedNodesByTimestamps(e,data)
                svg.selectAll('g').remove()
                d3.select(`#data${d.id}`)
                    .style("opacity", '0.8')
                tooltipBars.transition()		
                    .duration(500)		
                    .style("opacity", 0);
                drawBars(originalData, data, svg)
            })
            .on("click", function(e,d){
                timestamp = d.timestamps[0]
                if(d.measure === "day"){
                    getTimeStampByHour(timestamps, data, timestamp.date,timestamp.month,timestamp.year)
                }else if(d.measure === "hour"){
                    getTimeStampByMinute(timestamps, data, timestamp.hour, timestamp.date,timestamp.month,timestamp.year)
                }else if(d.measure === 'min'){
                    console.log("measure minute")
                    selectTimeStampByMinute(timestamps, data, timestamp.min, timestamp.hour, timestamp.date,timestamp.month,timestamp.year)
                }
                console.log("after update")
                console.log(data)
                selectedNodesByTimestamps(e,data)
                d3.select(`#data${d.id}`)
                    .style("opacity", '0.8')
                tooltipBars.transition()		
                    .duration(500)		
                    .style("opacity", 0);
                d3.selectAll('rect')
                    .style("fill", 'steelblue')
                d3.select(`#data${d.id}`)
                    .style("fill", 'red')
            })

            dataBars.exit().remove()


            svg.on("click", function(e){
                deselectSelectedNodes()
                d3.selectAll('rect')
                    .style("fill", 'steelblue')
                    .style("opacity", '0.8')
            })

            g.append('text')
                .attr('x', innerWidth/2)
                .attr('y', innerHeight+margin.bottom*0.8)
                .style('fill','black')
                .attr("text-anchor","middle")
                .text(`${xAxisLabel}`)

    }

    function getTimeStampByDate(originalData, updatableData){
        updatableData.length = 0
        let timeMap = new Map()
        originalData.forEach(timeData =>{
            let key = timeData.year+""+timeData.month+""+timeData.date
            if (timeMap.has(key)){
                let count  = timeMap.get(key).count+1
                let timestamps = timeMap.get(key).timestamps
                timestamps.push(timeData)
                timeMap.set(key, {count: count, timestamps: timestamps})
            }else{
                timeMap.set(key, {count: 1, timestamps:[timeData]})
            }
        })
        timeMap.forEach((value, key, map)=>{
            let dateString = new Date(value.timestamps[0].timestamp).toDateString()
            let id = key
            updatableData.push({
                measure: "day",
                id: id,
                xLabel: dateString,
                timestamps: value.timestamps,
                count: value.count
            })
        })
        xAxisLabel = "Days"
        console.log(updatableData)
    }

    function getTimeStampByHour(originalData, updatableData, date, month, year){
        updatableData.length = 0
        let filteredData = originalData.filter(data => data.month === month &&
                                                       data.year === year &&
                                                       data.date === date);                                                   
        let timeMap = new Map()
        for (let i = 0; i<24; i++){
            timeMap.set(i, {count: 0, timestamps:[]})
        }
        console.log(timeMap)
        xAxisLabel = "Hours ("+new Date(filteredData[0].timestamp).toDateString()+")"
        filteredData.forEach(timeData =>{
            let key = timeData.hour
            let count  = timeMap.get(key).count+1
            let timestamps = timeMap.get(key).timestamps
            timestamps.push(timeData)
            timeMap.set(key, {count: count, timestamps: timestamps})
        })
        timeMap.forEach((value, key, map)=>{
            let id = year+""+month+""+date+""+key
            let xLabel = `${getStandardHour(key)}${getAmPm(key)}-${getStandardHour(key+1)}${getAmPm(key+1)}`
            // if (key<11){
            //     xLabel = `${key}AM-${key+1}AM`
            // }else if(key === 11){
            //     xLabel = `${key}AM-${key+1}PM`
            // }else if(key>11 && key<23){
            //     xLabel = `${key%12}PM-${(key+1)%12}PM`
            // }else{
            //     xLabel = `${key%12}PM-${(key+1)%12}AM`
            // }
            updatableData.push({
                measure: "hour",
                id: id,
                xLabel: xLabel,
                timestamps: value.timestamps,
                count: value.count
            })
        })
        console.log(updatableData)
    }


    function getTimeStampByMinute(originalData, updatableData, hour,date, month, year){
        updatableData.length = 0
        let filteredData = originalData.filter(data => data.month === month &&
                                                       data.year === year &&
                                                       data.date === date &&
                                                       data.hour === hour);                                                   
        let timeMap = new Map()
        for (let i = 5; i<=60; i+=5){
            timeMap.set(i, {count: 0, timestamps:[]})
        }
        
        console.log(filteredData)
        xAxisLabel = "Minutes ("+new Date(filteredData[0].timestamp).toDateString()+" from "
                        + `${getStandardHour(hour)}${getAmPm(hour)} to ${getStandardHour(hour+1)}${getAmPm(hour+1)})`
        filteredData.forEach(timeData =>{
            let key = Math.ceil(timeData.min/5)*5
            if(key === 0){
                key = 5
            }
            let count  = timeMap.get(key).count+1
            let timestamps = timeMap.get(key).timestamps
            timestamps.push(timeData)
            timeMap.set(key, {count: count, timestamps: timestamps})
        })
        timeMap.forEach((value, key, map)=>{
            let id = year+""+month+""+date+""+hour+""+key
            let xLabel = ""
            if (key<=55){
                xLabel = `${getStandardHour(hour)}:${key-5<10?"0"+(key-5):key-5}${getAmPm(hour)}-${getStandardHour(hour)}:${key<10?"0"+key:key}${getAmPm(hour)}`
            }else{
                xLabel = `${getStandardHour(hour)}:${key-5}${getAmPm(hour)}-${getStandardHour(hour+1)}:00${getAmPm(hour+1)}`
            }
            // if (hour<11){
            //     xLabel = `${hour}:${key-5}AM-${hour}:${key}AM`
            // }else if(key === 11){
            //     xLabel = `${hour}:${key-5}AM-${hour}:${key}PM`
            // }else if(key>11 && key<23){
            //     xLabel = `${hour%12}:${key-5}PM-${(hour)%12}:${key}PM`
            // }else{
            //     xLabel = `${hour%12}:${key-5}PM-${(hour)%12}:${key}AM`
            // }
            updatableData.push({
                measure: "min",
                id: id,
                xLabel: xLabel,
                timestamps: value.timestamps,
                count: value.count
            })
        })
    }

    function selectTimeStampByMinute(originalData, updatableData, minute, hour,date, month, year){
        getTimeStampByMinute(originalData, updatableData,hour, date, month, year)
        let key = Math.ceil(minute/5)*5
        if(key === 0){
            key = 5
        }
        let id = year+""+month+""+date+""+hour+""+key
        newData = updatableData.filter(datapoint => datapoint.id === id)
        updatableData.length = 0
        newData.forEach(item => updatableData.push(item))
    }

    function selectedNodesByTimestamps(event, dataVals) {
        if (selectedNodeId) {
            d3.select("#circle" + selectedNodeId).classed("selectedNode", false);
            d3.selectAll(`.from${selectedNodeId},.to${selectedNodeId}`)
                .classed("highlightedEdges", false);
        }
        d3.selectAll("path").classed("dimmedEdges", true);
        selectedNodesIds.forEach(id => {
            d3.select("#circle" + id).classed("selectedNode", false);
            d3.selectAll(`.from${id},.to${id}`)
                .classed("highlightedEdges", false);
        })
        selectedNodesIds.length = 0
        dataVals.forEach(data =>{
            data.timestamps.forEach(item =>{
                d3.select("#circle" + item.nodeId).classed("selectedNode", true);
                selectedNodesIds.push(item.nodeId);
                d3.selectAll(`.from${item.nodeId},.to${item.nodeId}`)
                    .classed("highlightedEdges", true);
            })
        })
        event.stopPropagation();
    }

    function getAmPm(hour){
        if (hour <= 11 || hour === 24)
            return 'AM'
        else
            return 'PM'
    }

    function getStandardHour(hour){
        if (hour === 0 || hour === 24){
            return 12
        }else if(hour > 12){
            return hour%12
        }else{
            return hour
        }
    }

    function goBack(e){
        if(curr_time_measures.measure === "hour"){
            getTimeStampByDate(timestamps, updatableData)
            curr_time_measures = {measure: "day"}
            document.getElementById('goBackButton').disabled = true;
        }else if(curr_time_measures.measure === "min"){
            getTimeStampByHour(timestamps, updatableData, curr_time_measures.date,curr_time_measures.month, curr_time_measures.year)
            curr_time_measures = {measure: "hour", date: timestamp.date, month: timestamp.month,year: timestamp.year}
        }
        selectedNodesByTimestamps(window.event,updatableData)
        bar_svg.selectAll('g').remove()
        d3.select('.tooltipBars').transition()		
            .duration(500)		
            .style("opacity", 0);
        drawBars(timestamps, updatableData, bar_svg)
    }

</script>