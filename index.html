<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v6.js"></script>
<script src="scripts/preprocess.js"></script>

<style>
    .fakeRootElements {
        visibility: hidden;
    }
    .selectedNode {
        fill: lightseagreen;
        stroke: black;
        stroke-width: 2px;
    }
    #tooltip {
        position: absolute;			
        text-align: left;			
        width: auto;				
        height: auto;					
        padding: 5px;				
        font: 10px sans-serif;		
        background: lightsteelblue;	
        border: 0px;		
        border-radius: 8px;			
        pointer-events: none;
    }
    .attributeContainer {
        width: 100%;
    }
    .attributeLabel {
        width: 80px;
        display: inline;
    }
    .attributeValue {
        display: inline;
    }
</style>

<div>
    <input type="checkbox" name="treeEdgeColoring" onclick="updateEdgeColors('tree')" checked>
    <label for="treeEdgeColoring">Use divergent coloring on tree edges</label>
    <input type="checkbox" name="extraEdgeAcrossColoring" onclick="updateEdgeColors('extraWithin')" checked>
    <label for="extraEdgeAcrossColoring">Use divergent coloring on extra edges within level</label>
    <input type="checkbox" name="extraEdgeAcrossColoring" onclick="updateEdgeColors('extraAcross')" checked>
    <label for="extraEdgeAcrossColoring">Use divergent coloring on extra edges across levels</label>
</div>
<!-- Create a div where the graph will take place -->
<div id="viz">
    <div id="tooltip">
        <div class="attributeContainer">
            <div class="attributeLabel">Node ID:</div>
            <div class="attributeValue" id="idField">###</div>
        </div>
        <div class="attributeContainer">
            <div class="attributeLabel">Timestamp:</div>
            <div class="attributeValue" id="timestampField">###</div>
        </div>
        <div class="attributeContainer">
            <div class="attributeLabel">Number of Likes:</div>
            <div class="attributeValue" id="numLikesField">###</div>
        </div>
        <div class="attributeContainer">
            <div class="attributeLabel">Number of Comments:</div>
            <div class="attributeValue" id="numCommentsField">###</div>
        </div>
        <div class="attributeContainer">
            <div class="attributeLabel">Degree of Contribution:</div>
            <div class="attributeValue" id="degContributionField">###</div>
        </div>
    </div>
    <svg>
        <defs>
            <linearGradient id="verticalGradFollowedUp" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
                <stop offset="100%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
            </linearGradient>
            <linearGradient id="verticalGradFollowerUp" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
                <stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
            </linearGradient>
            <linearGradient id="horizontalGradFollowedLeft" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
                <stop offset="100%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
            </linearGradient>
            <linearGradient id="horizontalGradFollowerLeft" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" style="stop-color:rgb(0,0,255);stop-opacity:1" />
                <stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
            </linearGradient>
        </defs>
    </svg>
</div>

<script>
    /* UI variables */
    var useGradientOnTreeEdges = true;
    var useGradientOnExtraEdgesWithin = true;
    var useGradientOnExtraEdgesAcross = true;
    var selectedNode = null;

    /* svg variables */
    var svg = d3.select("#viz").select("svg");
    var solidEdgeColor = "#555";

    /* data loading and preprocessing */
    var nodeData;   // list of nodes
    var linkData;   // list of links
    var nodeLookup = {};    // maps node id to node object for easy lookup
    var fakeRoot;   // used to store all level 0 nodes as children for easier drawing
    
    d3.json("data/nodesAndLinks.json").then(function(data) {
        nodeData = data.nodes;
        linkData = data.links;
        preprocessData(nodeData, linkData, nodeLookup);   // transform data into the format we want
        console.log(nodeData);
        fakeRoot = transformToNested(nodeData);
        Tree(fakeRoot, {
            /*label: d => d.id,*/
            width: 1000
        });
    });

    // Copyright 2021 Observable, Inc.
    // Released under the ISC license.
    // https://observablehq.com/@d3/tree
    function Tree(data, { // data is either tabular (array of objects) or hierarchy (nested objects)
        path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes
        id = Array.isArray(data) ? d => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)
        parentId = Array.isArray(data) ? d => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier
        children, // if hierarchical data, given a d in data, returns its children
        tree = d3.tree, // layout algorithm (typically d3.tree or d3.cluster)
        sort, // how to sort nodes prior to layout (e.g., (a, b) => d3.descending(a.height, b.height))
        label, // given a node d, returns the display name
        title, // given a node d, returns its hover text
        link, // given a node d, its link (if any)
        linkTarget = "_blank", // the target attribute for links (if any)
        width = 640, // outer width, in pixels
        height, // outer height, in pixels
        r = 4, // radius of nodes
        padding = 1, // horizontal padding for first and last column
        fill = "#999", // fill for nodes
        fillOpacity, // fill opacity for nodes
        stroke = "#555", // stroke for links
        strokeWidth = 1.5, // stroke width for links
        strokeOpacity = 0.4, // stroke opacity for links
        strokeLinejoin, // stroke line join for links
        strokeLinecap, // stroke line cap for links
        halo = "#fff", // color of label halo 
        haloWidth = 3, // padding around the labels
        } = {})
    {
        // If a path accessor is specified, we can impute the internal nodes from the slash-
        // separated path; otherwise, the tabular data must include the internal nodes, not
        // just leaves. TODO https://github.com/d3/d3-hierarchy/issues/33
        if (path != null) {
            const D = d3.map(data, d => d);
            const I = d3.map(data, path).map(d => (d = `${d}`).startsWith("/") ? d : `/${d}`);
            const paths = new Set(I);
            for (const path of paths) {
            const parts = path.split("/");
            while (parts.pop(), parts.length) {
                const path = parts.join("/") || "/";
                if (paths.has(path)) continue;
                paths.add(path), I.push(path), D.push(null);
            }
            }
            id = (_, i) => I[i];
            parentId = (_, i) => I[i] === "/" ? "" : I[i].slice(0, I[i].lastIndexOf("/")) || "/";
            data = D;
        }

        // If id and parentId options are specified (perhaps implicitly via the path option),
        // use d3.stratify to convert tabular data to a hierarchy; otherwise we assume that
        // the data is specified as an object {children} with nested objects (a.k.a. the
        // “flare.json” format), and use d3.hierarchy.
        const root = id == null && parentId == null
            ? d3.hierarchy(data, children)
            : d3.stratify().id(id).parentId(parentId)(data);

        // Compute labels and titles.
        const descendants = root.descendants();
        const L = label == null ? null : descendants.map(d => label(d.data, d));

        // Sort the nodes.
        if (sort != null) root.sort(sort);
        // Compute the layout.
        const dx = 10;
        const dy = width / (root.height + padding);
        tree().nodeSize([dx, dy])(root);

        // Center the tree.
        let x0 = Infinity;
        let x1 = -x0;
        root.each(d => {
            if (d.x > x1) x1 = d.x;
            if (d.x < x0) x0 = d.x;
        });

        // Compute the default height.
        if (height === undefined) height = x1 - x0 + dx * 2;

        svg.attr("viewBox", [-dy * padding / 2, x0 - dx, width, height])
            .attr("width", width)
            .attr("height", height)
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
            .attr("font-family", "sans-serif")
            .attr("font-size", 10);

        svg.append("g")
            .attr("fill", "none")
            .attr("stroke-opacity", strokeOpacity)
            .attr("stroke-linecap", strokeLinecap)
            .attr("stroke-linejoin", strokeLinejoin)
            .attr("stroke-width", strokeWidth)
            .selectAll("path")
            .data(root.links())
            .join("path")
            .classed("fakeRootElements", d => d.source.data.id == "0")
            .classed("treeEdges", true)
            .attr("stroke", getGradientForTreeLink)
            .attr("id", d => "link" + d.source.data.id + "to" + d.target.data.id)
            .attr("d", computePathCommands);

        const node = svg.append("g")
            .selectAll("a")
            .data(root.descendants())
            .join("a")
            .classed("fakeRootElements", d => d.data.id == "0")
            .attr("id", d => "node" + d.data.id)
            .attr("xlink:href", link == null ? null : d => link(d.data, d))
            .attr("target", link == null ? null : linkTarget)
            .attr("transform", d => `translate(${d.y},${d.x})`);

        node.append("circle")
            .attr("fill", d => d.children ? stroke : fill)
            .attr("r", r)
            .on('click', updateSelectedNode);

        let extraLinksBetweenNodes = getLinksBetweenNodes(root.descendants(), true, true);
        svg.append("g")
            .attr("fill", "none")
            .attr("stroke-opacity", strokeOpacity)
            .attr("stroke-linecap", strokeLinecap)
            .attr("stroke-linejoin", strokeLinejoin)
            .attr("stroke-width", strokeWidth)
            .selectAll("path")
            .data(extraLinksBetweenNodes)
            .join("path")
            .classed("extraEdgesBetweenNodes", true)
            .classed("extraEdgesAcrossLevels", d => !d.sameLevel)
            .classed("extraEdgesWithinLevels", d => d.sameLevel)
            .attr("stroke", getGradientForLink)
            .attr("d", drawPathBetweenNodes);

        if (title != null) node.append("title")
            .text(d => title(d.data, d));

        if (L) node.append("text")
            .attr("dy", "0.32em")
            .attr("x", d => d.children ? -6 : 6)
            .attr("text-anchor", d => d.children ? "end" : "start")
            .text((d, i) => L[i])
            .call(text => text.clone(true))
            .attr("fill", "none")
            .attr("stroke", halo)
            .attr("stroke-width", haloWidth);
    }
    function getLinksBetweenNodes(nodeElems, includeAllLevels=false, includeDifferentParents=false) {
        let links = [];
        let nodeElemMap = {};   // build lookup map to easily access node element by id
        nodeElems.forEach(function (node) {
            nodeElemMap[node.data.id] = node;
        });
        nodeData.forEach(function (node) {
            let nonDirectParents = node.parents.filter(nId => nId != node.directParent);   // get only the non-direct parents, which are the nodes after the first parent node
            nonDirectParents.forEach(function (parentId) {
                let parentNode = nodeLookup[parentId];
                if (includeAllLevels || node.level == parentNode.level) { // if not including all levels, get only the links between children in the same level
                    if (includeDifferentParents || node.directParent == parentNode.directParent) { // if not including nodes with different parents, get only the links between children under the same parent
                        // this node follows the parent node, so set this node as source and parent node as target
                        links.push({
                            source: nodeElemMap[node.id],
                            target: nodeElemMap[parentId],
                            sameLevel: node.level == parentNode.level
                        });
                    }
                }
            })
        });
        return links;
    }
    function computePathCommands(d) {
        let getPath = d3.linkHorizontal()
            .x(d => d.y)
            .y(d => d.x);
        let pathString = getPath(d).split("C");
        let subPathStrings = [pathString[0].split(","), pathString[1].split(",")];
        let parsedInt1 = parseFloat(subPathStrings[0][1]);
        let parsedInt2 = parseFloat(subPathStrings[1][5]);
        if (parsedInt1 == parsedInt2) { // path is a straight line, tweak it to make it not straight
            parsedInt1 -= 0.25;
            parsedInt2 += 0.25;
            subPathStrings[0][1] = parsedInt1.toString();
            subPathStrings[1][5] = parsedInt2.toString();
            pathString[0] = subPathStrings[0].join(",");
            pathString[1] = subPathStrings[1].join(",");
        }
        return pathString.join("C");
    }
    function getGradientForTreeLink(d) {
        if (!useGradientOnTreeEdges) return solidEdgeColor;
        return "url(#horizontalGradFollowedLeft)";
    }
    function getGradientForLink(d) {
        if (d.source.data.level == d.target.data.level) {  // drawing an arc since nodes are on the same level
            if (!useGradientOnExtraEdgesWithin) return solidEdgeColor;
            if (d.source.x > d.target.x) {  // the arc goes from follower to followed node downward
                return "url(#verticalGradFollowedUp)";
            } else {    // otherwise the arc goes from follower to followed node upward
                return "url(#verticalGradFollowerUp)";
            }
        } else {    // drawing an edge between different levels
            if (!useGradientOnExtraEdgesAcross) return solidEdgeColor;
            if (d.source.data.level < d.target.data.level) {   // the edge goes from an earlier level to later level
                return "url(#horizontalGradFollowerLeft)";
            } else {    // otherwise the edge goes from a later level to earlier level
                return "url(#horizontalGradFollowedLeft)";
            }
        }
    }
    function drawPathBetweenNodes(d) {
        if (d.source.data.level == d.target.data.level) { 
            return drawArcBetweenSameLevel(d);
        }
        let edgeFunct = d3.linkHorizontal()
            .x(dt => dt.y)
            .y(dt => dt.x);
        return edgeFunct(d);
    }
    function drawArcBetweenSameLevel(d) {
        let start = d.source.x;    // X position of start node on the X axis
        let end = d.target.x;      // X position of end node
        let height = d.source.y; // this would be the same for the two points since they are in the same level
        return ['M', height, start,    // the arc starts at the coordinate x=start, y=height-30 (where the starting node is)
            'A',                            // This means we're gonna build an elliptical arc
            (start - end)/2, ',',    // Next 2 lines are the coordinates of the inflexion point. Height of this point is proportional with start - end distance
            (start - end)/2, 0, 0, ',',
            start < end ? 1 : 0, height, ',', end] // We always want the arc on top. So if end is before start, putting 0 here turn the arc upside down.
            .join(' ');
    }
    function updateEdgeColors(type) {
        if (type == "tree") {
            useGradientOnTreeEdges = useGradientOnTreeEdges ? false : true;
            svg.selectAll(".treeEdges")
                .attr("stroke", getGradientForTreeLink);
        } else if (type == "extraAcross") {
            useGradientOnExtraEdgesAcross = useGradientOnExtraEdgesAcross ? false : true;
            svg.selectAll(".extraEdgesAcrossLevels")
                .attr("stroke", getGradientForLink);
        } else {
            useGradientOnExtraEdgesWithin = useGradientOnExtraEdgesWithin ? false : true;
            svg.selectAll(".extraEdgesWithinLevels")
                .attr("stroke", getGradientForLink);
        }
    }
    function updateSelectedNode(event, d) {
        let newSelectedNode = d3.select(this);
        if (selectedNode != newSelectedNode) {    // a new node has been selected
            newSelectedNode.classed("selectedNode", true);
            if (selectedNode) {
                selectedNode.classed("selectedNode", false);
            }
            selectedNode = newSelectedNode;
        }
        d3.select("#idField").html(d.data.id);
        d3.select("#timestampField").html(d.data.timestamp);
        d3.select("#numLikesField").html(d.data.numLikes);
        d3.select("#numCommentsField").html(d.data.numComments);
    }
</script>